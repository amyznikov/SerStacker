/*
 * flow-color.cc
 *
 *  Created on: May 14, 2018
 *      Author: amyznikov
 */

#include <core/proc/flow-color.h>
#include <core/debug.h>


//
// Color encoding of flow vectors
//
// Ported to OpenCV from original optical flow input/output code
// provided as part of the Sintel dataset
//  http://sintel.is.tue.mpg.de/
//  http://members.shaw.ca/quadibloc/other/colint.htm
//
///////////////////////////////////////////////////////////////////////////////
using namespace cv;

/*
 * This lookup table is pre-generated by the makecolorwheel() code at bottom
 * */
static int g_flow_color_lut[][3] = {
    { 255, 0, 0 }, //    0
    { 255, 17, 0 }, //    1
    { 255, 34, 0 }, //    2
    { 255, 51, 0 }, //    3
    { 255, 68, 0 }, //    4
    { 255, 85, 0 }, //    5
    { 255, 102, 0 }, //    6
    { 255, 119, 0 }, //    7
    { 255, 136, 0 }, //    8
    { 255, 153, 0 }, //    9
    { 255, 170, 0 }, //   10
    { 255, 187, 0 }, //   11
    { 255, 204, 0 }, //   12
    { 255, 221, 0 }, //   13
    { 255, 238, 0 }, //   14
    { 255, 255, 0 }, //   15
    { 213, 255, 0 }, //   16
    { 170, 255, 0 }, //   17
    { 128, 255, 0 }, //   18
    { 85, 255, 0 }, //   19
    { 43, 255, 0 }, //   20
    { 0, 255, 0 }, //   21
    { 0, 255, 63 }, //   22
    { 0, 255, 127 }, //   23
    { 0, 255, 191 }, //   24
    { 0, 255, 255 }, //   25
    { 0, 232, 255 }, //   26
    { 0, 209, 255 }, //   27
    { 0, 186, 255 }, //   28
    { 0, 163, 255 }, //   29
    { 0, 140, 255 }, //   30
    { 0, 116, 255 }, //   31
    { 0, 93, 255 }, //   32
    { 0, 70, 255 }, //   33
    { 0, 47, 255 }, //   34
    { 0, 24, 255 }, //   35
    { 0, 0, 255 }, //   36
    { 19, 0, 255 }, //   37
    { 39, 0, 255 }, //   38
    { 58, 0, 255 }, //   39
    { 78, 0, 255 }, //   40
    { 98, 0, 255 }, //   41
    { 117, 0, 255 }, //   42
    { 137, 0, 255 }, //   43
    { 156, 0, 255 }, //   44
    { 176, 0, 255 }, //   45
    { 196, 0, 255 }, //   46
    { 215, 0, 255 }, //   47
    { 235, 0, 255 }, //   48
    { 255, 0, 255 }, //   49
    { 255, 0, 213 }, //   50
    { 255, 0, 170 }, //   51
    { 255, 0, 128 }, //   52
    { 255, 0, 85 }, //   53
    { 255, 0, 43 }, //   54
};



/*
 * Compute BGR color for given flow vector
 * */
void compute_flow_color(double fx, double fy, uint8_t pix[3])
{
  const size_t ncols = sizeof(g_flow_color_lut) / sizeof(g_flow_color_lut[0]);

  double rad = ::hypot(fx,fy);
  double a = atan2(-fy, -fx) / M_PI;

  double  fk = (a + 1.0) / 2.0 * (ncols - 1);

  int k0 = (int) fk;
  int k1 = (k0 + 1) % ncols;
  double f = fk - k0;

  // f = 0; // uncomment to see original color wheel

  for ( int b = 0; b < 3; b++ ) {
    double col0 = g_flow_color_lut[k0][b] / 255.0;
    double col1 = g_flow_color_lut[k1][b] / 255.0;
    double col = (1 - f) * col0 + f * col1;

    if ( rad <= 1 ) {
      col = 1 - rad * (1 - col); // increase saturation with radius
    }
    else {
      col *= .75; // out of range
    }

    pix[2 - b] = (int) (255.0 * col);
  }
}


/*
 * Create flow BGR image
 *  flow: 2-channel input flow matrix of type T
 *  dst : output BRG image
 * */
template<class T>
static bool flow2color_(const cv::Mat & flow, cv::Mat & _dst, double maxmotion = -1)
{
  Mat dst (flow.size(), CV_8UC3);

  typedef Point_<T> PointT;

  int x, y;

  // determine motion range:
  double maxx = -999, maxy = -999;
  double minx = 999, miny = 999;
  double maxrad = -1;
  double d;

  for ( y = 0; y < flow.rows; y++ ) {

    const PointT * fp = flow.ptr<const PointT>(y);

    for ( x = 0; x < flow.cols; x++ ) {

      const PointT & f = fp[x];

      if ( !unknown_flow(f) ) {
        if ( f.x > maxx ) {
          maxx = f.x;
        }
        if ( f.x < minx ) {
          minx = f.x;
        }
        if ( f.y > maxy ) {
          maxy = f.y;
        }
        if ( f.y < miny ) {
          miny = f.y;
        }
        if ( (d = hypot(f.x, f.y)) > maxrad ) {
          maxrad = d;
        }
      }
    }
  }

  if ( maxmotion > 0 ) { // i.e., specified on commandline
    maxrad = maxmotion;
  }

  if ( maxrad <= 0 ) { // if flow == 0 everywhere
    maxrad = 1;
  }

  for ( y = 0; y < flow.rows; y++ ) {

    const PointT * fp = flow.ptr<const PointT>(y);
    Vec3b * cp = dst.ptr<Vec3b>(y);

    for ( x = 0; x < flow.cols; x++ ) {

      const PointT & f = fp[x];
      Vec3b & c = cp[x];

      if ( unknown_flow(f) ) {
        c.val[0] = c.val[1] = c.val[2] = 0;
      }
      else {
        compute_flow_color(f.x / maxrad, f.y / maxrad, c.val);
      }
    }
  }

  _dst = dst;
  return true;
}


/*
 * Create flow BGR image
 *  flow: 2-channel input flow matrix
 *  dst : output BRG image
 * */
bool flow2color(cv::InputArray flow, cv::Mat & dst, double maxmotion)
{
  const Mat src = flow.getMat();

  if ( src.channels() != 2 ) {
    CF_FATAL("Unsupported number of channels: %d. 2-channel image expected", flow.channels());
    return false;
  }

  switch ( flow.depth() ) {
  case CV_8U:
    return flow2color_<uint8_t>(src, dst, maxmotion);
  case CV_8S:
    return flow2color_<int8_t>(src, dst, maxmotion);
  case CV_16U:
    return flow2color_<uint16_t>(src, dst, maxmotion);
  case CV_16S:
    return flow2color_<int16_t>(src, dst, maxmotion);
  case CV_32S:
    return flow2color_<int32_t>(src, dst, maxmotion);
  case CV_32F:
    return flow2color_<float>(src, dst, maxmotion);
  case CV_64F:
    return flow2color_<double>(src, dst, maxmotion);
  }

  CF_FATAL("Unsupported image depth %d.", flow.depth());
  return false;
}



/*
 * Create flow BGR image using HSV color space
 *  flow: 2-channel input flow matrix
 *  dst : output BRG image
 *
 *  The code is extracted from OpenCV example dis_opticalflow.cpp
 * */
bool flow2colorHSV(cv::InputArray src, cv::Mat & dst, double maxmotion, bool invert_y)
{
  const Mat flow = src.getMat();
  if ( src.channels() != 2 ) {
    CF_FATAL("Unsupported number of channels: %d. 2-channel image expected", flow.channels());
    return false;
  }

  Mat uv[2], mag, ang;

  split(flow, uv);

  if ( flow.depth() == CV_32F || flow.depth() == CV_64F ) {
    if ( invert_y ) {
      multiply(uv[1], -1, uv[1]);
    }
  }
  else {
    uv[0].convertTo(uv[0], CV_32F);
    uv[1].convertTo(uv[1], CV_32F, invert_y ? -1 : 1);
  }

  cartToPolar(uv[0], uv[1], mag, ang, true);

  if ( maxmotion > 0 ) {
    threshold(mag, mag, maxmotion, maxmotion, cv::THRESH_TRUNC);
  }

  normalize(mag, mag, 0, 1, NORM_MINMAX);

  const Mat hsv[3] = {
      ang,
      mag,
      Mat::ones(ang.size(), ang.type())
  };

  merge(hsv, 3, dst);
  cvtColor(dst, dst, COLOR_HSV2BGR);
  dst.convertTo(dst, CV_8U, 255);

  return true;
}


/*
 * Create flow BGR image using HSV color space
 *  fx: 1-channel input flow matrix
 *  fy: 1-channel input flow matrix
 *  dst : output BRG image
 *
 *  The code is extracted from OpenCV example dis_opticalflow.cpp
 * */
bool flow2colorHSV(cv::InputArray fx, cv::InputArray fy, cv::Mat & dst, double maxmotion, bool invert_y)
{
  Mat channels[2] = { fx.getMat(), fy.getMat() };
  Mat flow;
  merge(channels, 2, flow);
  return flow2colorHSV(flow, dst, maxmotion, invert_y);
}


void drawHsvRing(int radius, Mat & dst, Mat * omask)
{
  const Size size(2 * radius + 1, 2 * radius + 1);

  Mat hsv[3] = {
      Mat::zeros(size, CV_32F),
      Mat::zeros(size, CV_32F),
      Mat::ones(size, CV_32F),
  };

  if ( omask ) {
    omask->create(size, CV_8UC1);
    omask->setTo(0);
  }

  for ( int y = 0; y < size.height; ++y ) {

    float * hp = hsv[0].ptr<float>(y);
    float * sp = hsv[1].ptr<float>(y);
    uint8_t * mp = omask ? omask->ptr<uint8_t>(y) : NULL;

    for ( int x = 0; x < size.width; ++x ) {
      double r = ::hypot(x - radius, y - radius);
      if ( r < radius ) {

        double a, s;
        if ( r < 1 ) {
          a = 0, s = 0;
        }
        else {
          a = atan2(radius - y, radius - x) * 180 / M_PI + 180;
          s = r / radius;
        }

        hp[x] = a;
        sp[x] = s;

        if ( mp ) {
          mp[x] = 255;
        }
      }
    }
  }

  cv::merge(hsv, 3, dst);
  cv::cvtColor(dst, dst, COLOR_HSV2BGR);
  dst.convertTo(dst, CV_8U, 255);
}




//
// The commented code below can be used to rebuild the lookup table above
// For details see
//  https://github.com/davidstutz/flow-io-opencv/blob/master/lib/colorcode.cpp
//
#if 0
//int ncols = 0;
//#define MAXCOLS 60
//int colorwheel[MAXCOLS][3];
//
//void setcols(int r, int g, int b, int k)
//{
//    colorwheel[k][0] = r;
//    colorwheel[k][1] = g;
//    colorwheel[k][2] = b;
//}
//
//void makecolorwheel()
//{
//    // relative lengths of color transitions:
//    // these are chosen based on perceptual similarity
//    // (e.g. one can distinguish more shades between red and yellow
//    //  than between yellow and green)
//    int RY = 15;
//    int YG = 6;
//    int GC = 4;
//    int CB = 11;
//    int BM = 13;
//    int MR = 6;
//    ncols = RY + YG + GC + CB + BM + MR;
//    //printf("ncols = %d\n", ncols);
//    if (ncols > MAXCOLS)
//  exit(1);
//    int i;
//    int k = 0;
//    for (i = 0; i < RY; i++) setcols(255,    255*i/RY,   0,        k++);
//    for (i = 0; i < YG; i++) setcols(255-255*i/YG, 255,    0,        k++);
//    for (i = 0; i < GC; i++) setcols(0,      255,    255*i/GC,     k++);
//    for (i = 0; i < CB; i++) setcols(0,      255-255*i/CB, 255,        k++);
//    for (i = 0; i < BM; i++) setcols(255*i/BM,     0,    255,        k++);
//    for (i = 0; i < MR; i++) setcols(255,    0,    255-255*i/MR, k++);
//}
//
//int main()
//{
//
//  makecolorwheel();
//
//  for ( int i = 0; i < ncols; ++i ) {
//    printf("\t{%4d,%4d,%4d}, // %4d\n", colorwheel[i][0], colorwheel[i][1], colorwheel[i][2], i);
//  }
//
//  printf("ncols=%d\n", ncols);
//  return 0;
//}
//
#endif



///////////////////////////////////////////////////////////////////////////////
