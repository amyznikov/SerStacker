/*
 * QThumbnails.cc
 *
 *  Created on: Mar 6, 2020
 *      Author: amyznikov
 */

#include <opencv2/opencv.hpp>
#include <core/io/load_image.h>
#include "QThumbnails.h"

#include <core/io/c_ser_file.h>
#include <core/io/c_fits_file.h>

#define HAVE_FFMPEG_READER 1
#include <core/io/c_ffmpeg_file.h>


#if HAVE_LIBOPENRAW // come from cmake
# undef HAVE_LIBRAW
# include <libopenraw/libopenraw.h>
#elif HAVE_LIBRAW
# include <libraw/libraw.h>
#endif

#include <core/debug.h>

#if HAVE_LIBRAW
// https://api.kde.org/libkdcraw/html/rawfiles_8h_source.html
static const char * raw_file_extentions[] = {
    // NOTE: VERSION 1
    "bay",// Casio Digital Camera Raw File Format.
    "bmq",  // NuCore Raw Image File.
    "cr2",  // Canon Digital Camera RAW Image Format version 2.0. These images are based on the TIFF image standard.
    "crw",  // Canon Digital Camera RAW Image Format version 1.0.
    "cs1",  // Capture Shop Raw Image File.
    "dc2",  // Kodak DC25 Digital Camera File.
    "dcr",  // Kodak Digital Camera Raw Image Format for these models: Kodak DSC Pro SLR/c, Kodak DSC Pro SLR/n, Kodak DSC Pro 14N, Kodak DSC PRO 14nx.
    "dng",  // Adobe Digital Negative: DNG is publicly available archival format for the raw files generated by digital cameras. By addressing the lack of an open standard for the raw files created by individual camera models, DNG helps ensure that photographers will be able to access their files in the future.
    "erf",  // Epson Digital Camera Raw Image Format.
    "fff",  // Imacon Digital Camera Raw Image Format.
    "hdr",  // Leaf Raw Image File.
    "k25",  // Kodak DC25 Digital Camera Raw Image Format.
    "kdc",  // Kodak Digital Camera Raw Image Format.
    "mdc",  // Minolta RD175 Digital Camera Raw Image Format.
    "mos",  // Mamiya Digital Camera Raw Image Format.
    "mrw",  // Minolta Dimage Digital Camera Raw Image Format.
    "nef",  // Nikon Digital Camera Raw Image Format.
    "orf",  // Olympus Digital Camera Raw Image Format.
    "pef",  // Pentax Digital Camera Raw Image Format.
    "pxn",  // Logitech Digital Camera Raw Image Format.
    "raf",  // Fuji Digital Camera Raw Image Format.
    "raw",  // Panasonic Digital Camera Image Format.
    "rdc",  // Digital Foto Maker Raw Image File.
    "sr2",  // Sony Digital Camera Raw Image Format.
    "srf",  // Sony Digital Camera Raw Image Format for DSC-F828 8 megapixel digital camera or Sony DSC-R1
    "x3f",  // Sigma Digital Camera Raw Image Format for devices based on Foveon X3 direct image sensor.
    "arw",  // Sony Digital Camera Raw Image Format for Alpha devices.

    // NOTE: VERSION 2
    "3fr",// Hasselblad Digital Camera Raw Image Format.
    "cine",  // Phantom Software Raw Image File.
    "ia",   // Sinar Raw Image File.
    "kc2",  // Kodak DCS200 Digital Camera Raw Image Format.
    "mef",  // Mamiya Digital Camera Raw Image Format.
    "nrw",  // Nikon Digital Camera Raw Image Format.
    "qtk",  // Apple Quicktake 100/150 Digital Camera Raw Image Format.
    "rw2",  // Panasonic LX3 Digital Camera Raw Image Format.
    "sti",  // Sinar Capture Shop Raw Image File.

    // NOTE: VERSION 3

    "rwl",// Leica Digital Camera Raw Image Format.

    // NOTE: VERSION 4

    "srw",// Samsung Raw Image Format.

    // NOTE: VERSION 5
    "drf",// Kodak Digital Camera Raw Image Format.
    "dsc",  // Kodak Digital Camera Raw Image Format.
    "ptx",  // Pentax Digital Camera Raw Image Format.
    "cap",  // Phase One Digital Camera Raw Image Format.
    "iiq",  // Phase One Digital Camera Raw Image Format.
    "rwz"  // Rawzor Digital Camera Raw Image Format.#endif
    };


static void add_libraw_file_suffixes(QStringList & suffixes)
{
  for ( uint i = 0; i < sizeof(raw_file_extentions)/sizeof(raw_file_extentions[0]); ++i ) {
    suffixes.append(raw_file_extentions[i]);
  }
}

#endif


const char ** thumbnail_textfile_suffixes()
{
  static const char * suffixes[] = {
      "txt", "doc", "md", "xml", "html", "htm", "rtf", "tex", "cfg", "conf", "yml", nullptr
  };

  return suffixes;
}

const char ** thumbnail_plyfile_suffixes()
{
  static const char * suffixes[] = {
      "ply", nullptr
  };

  return suffixes;
}

QSize compute_thumbnail_size(QSize srcSize, int max_thumb_size)
{
  if ( !srcSize.isEmpty() ) {

    if ( max_thumb_size > 0 && (srcSize.width() > max_thumb_size || srcSize.height() > max_thumb_size) ) {
      if ( srcSize.width() > srcSize.height() ) {
        srcSize.setHeight(srcSize.height() * max_thumb_size / srcSize.width());
        srcSize.setWidth(max_thumb_size);
      }
      else {
        srcSize.setWidth(srcSize.width() * max_thumb_size / srcSize.height());
        srcSize.setHeight(max_thumb_size);
      }
    }
  }

  return srcSize;
}


QStringList getSupportedThumbnailsExtensions()
{
  QStringList suffixes;

  //  qt5-imageformats
  QList<QByteArray> supportedFormats = QImageReader::supportedImageFormats();
  for ( const QByteArray & s : supportedFormats ) {
    suffixes.append(s.data());
  }


  suffixes.append("tiff");
  suffixes.append("tif");
  suffixes.append("flo");
  suffixes.append("ser");
  suffixes.append("exr");

  const char ** textfiles =
      thumbnail_textfile_suffixes();
  while ( *textfiles ) {
    suffixes.append(*textfiles++);
  }

  const char ** plyfiles =
      thumbnail_plyfile_suffixes();
  while ( *plyfiles ) {
    suffixes.append(*plyfiles++);
  }

#if HAVE_CFITSIO
  suffixes.append("fits");
  suffixes.append("fit");
#endif

#if HAVE_LIBOPENRAW
  const char ** raw_file_suffixes = or_get_file_extensions();
  if ( raw_file_suffixes ) {
    for ( int i = 0; raw_file_suffixes[i]; ++i ) {
      suffixes.append(raw_file_suffixes[i]);
    }
  }
#elif HAVE_LIBRAW
  add_libraw_file_suffixes(suffixes);
#endif


  for ( const std::string & s : c_ffmpeg_reader::supported_input_formats() ) {
    suffixes.append(s.c_str());
  }

  std::sort(suffixes.begin(), suffixes.end());
  QStringList::iterator ii = std::unique(suffixes.begin(), suffixes.end());
  if ( ii != suffixes.end() ) {
    suffixes.erase(ii, suffixes.end());
  }

  return suffixes;
}


static bool is_raw_file_suffix(const QString & suffix)
{
  (void) (suffix);

#if HAVE_LIBOPENRAW
  if ( !suffix.isEmpty() ) {
    const char ** raw_file_suffixes = or_get_file_extensions();
    if ( raw_file_suffixes ) {
      const std::string csuffix = suffix.toStdString();
      for ( int i = 0; raw_file_suffixes[i]; ++i ) {
        if ( strcasecmp(raw_file_suffixes[i], csuffix.c_str()) == 0 ) {
          return true;
        }
      }
    }
  }
#elif HAVE_LIBRAW
  if ( !suffix.isEmpty() ) {
    const std::string csuffix = suffix.toStdString();
    for ( uint i = 0; i < sizeof(raw_file_extentions)/sizeof(raw_file_extentions[0]); ++i ) {
      if ( strcasecmp(raw_file_extentions[i], csuffix.c_str()) == 0 ) {
        return true;
      }
    }
  }
#endif

  return false;
}

/*
 * Create flow BGR image using HSV color space
 *  flow: 2-channel input flow matrix
 *  dst : output BRG image
 *
 *  The code is extracted from OpenCV example dis_opticalflow.cpp
 * */
static bool flow2HSV(cv::InputArray flow, cv::Mat & dst, double maxmotion, bool invert_y)
{
  if ( flow.channels() != 2 ) {
    CF_FATAL("Unsupported number of channels: %d. 2-channel image expected", flow.channels());
    return false;
  }

  cv::Mat uv[2], mag, ang;

  cv::split(flow.getMat(), uv);

  if ( flow.depth() == CV_32F || flow.depth() == CV_64F ) {
    if ( invert_y ) {
      cv::multiply(uv[1], -1, uv[1]);
    }
  }
  else {
    uv[0].convertTo(uv[0], CV_32F);
    uv[1].convertTo(uv[1], CV_32F, invert_y ? -1 : 1);
  }

  cv::cartToPolar(uv[0], uv[1], mag, ang, true);

  if ( maxmotion > 0 ) {
    cv::threshold(mag, mag, maxmotion, maxmotion, cv::THRESH_TRUNC);
  }

  cv::normalize(mag, mag, 0, 1, cv::NORM_MINMAX);

  const cv::Mat hsv[3] = {
      ang,
      mag,
      cv::Mat::ones(ang.size(), ang.type())
  };

  cv::merge(hsv, 3, dst);
  cv::cvtColor(dst, dst, cv::COLOR_HSV2RGB);
  dst.convertTo(dst, CV_8U, 255);

  return true;
}


static bool cv2qimage(const cv::Mat & _src, QImage * dst, bool rgbswap)
{
  cv::Mat src;

  if (_src.channels() == 2 ) { // treat as optical flow marrix
    cv::Scalar m, s;
    cv::meanStdDev(_src, m, s);
    flow2HSV(_src, src, std::max(m[0], m[1]) + std::max(0.1, 5 * sqrt(s[0] * s[0] + s[1] * s[1])), true);
    rgbswap = false;
  }
  else if ( _src.depth() == CV_8U ) {
    src = _src;
  }
  else {
    cv::normalize(_src, src, 0, 255, cv::NORM_MINMAX);
    src.convertTo(src, CV_8U);
  }

  switch ( src.type() ) {
  case CV_8UC1 :
    if ( dst->format() != QImage::Format_Grayscale8 || dst->width() != src.cols
        || dst->height() != src.rows ) {
      *dst = QImage(src.cols, src.rows, QImage::Format_Grayscale8);
    }
    for ( int i = 0; i < src.rows; ++i ) {
      memcpy(dst->scanLine(i), src.ptr<const uint8_t>(i), src.cols);
    }
    return true;

  case CV_8UC3 :
    if ( dst->format() != QImage::Format_RGB888 || dst->width() != src.cols
        || dst->height() != src.rows ) {
      *dst = QImage(src.cols, src.rows, QImage::Format_RGB888);
    }

    if ( !rgbswap ) {
      for ( int i = 0; i < src.rows; ++i ) {
        memcpy(dst->scanLine(i), src.ptr<const uint8_t>(i), src.cols * 3);
      }
    }
    else {
      for ( int y = 0; y < src.rows; ++y ) {
        const cv::Vec3b * srcp = src.ptr<const cv::Vec3b>(y);
        cv::Vec3b * dstp = (cv::Vec3b *) dst->scanLine(y);
        for ( int x = 0; x < src.cols; ++x ) {
          dstp[x].val[0] = srcp[x].val[2];
          dstp[x].val[1] = srcp[x].val[1];
          dstp[x].val[2] = srcp[x].val[0];
        }
      }
    }
    return true;

  case CV_8UC4 :
    if ( dst->format() != QImage::Format_ARGB32 || dst->width() != src.cols
        || dst->height() != src.rows ) {
      *dst = QImage(src.cols, src.rows, QImage::Format_ARGB32);
    }
    for ( int i = 0; i < src.rows; ++i ) {
      memcpy(dst->scanLine(i), src.ptr<const uint8_t>(i), src.cols * 4);
    }
    return true;

  default :
    CF_FATAL("Unhandled cv type %d", src.type());
    break;
  }

  return false;
}

static QImage loadThumbnailImageFromRaw(const QString & pathFileName, int thumb_size)
{
  QImage qimage;

#if HAVE_LIBOPENRAW

  ORThumbnailRef thumbnail = nullptr;
  or_data_type thumbnailFormat = OR_DATA_TYPE_UNKNOWN;
  size_t dataSize = 0;
  uint32_t cx = 0, cy = 0;

  int status;

  const std::string cfilename = pathFileName.toStdString();

  status = or_get_extract_thumbnail(cfilename.c_str(),
      thumb_size, &thumbnail);

  if ( status != OR_ERROR_NONE ) {
    // CF_ERROR("or_get_extract_thumbnail() fails: status=%d", status);
  }
  else {

    thumbnailFormat = or_thumbnail_format(thumbnail);
    dataSize = or_thumbnail_data_size(thumbnail);
    or_thumbnail_dimensions(thumbnail, &cx, &cy);

    switch ( thumbnailFormat ) {
    case OR_DATA_TYPE_JPEG :
      qimage = QImage::fromData((uint8_t*) or_thumbnail_data(thumbnail), dataSize, "JPG");
      break;

    case OR_DATA_TYPE_TIFF :
      qimage = QImage::fromData((uint8_t*) or_thumbnail_data(thumbnail), dataSize, "TIFF");
      break;

    case OR_DATA_TYPE_PNG :
      qimage = QImage::fromData((uint8_t*) or_thumbnail_data(thumbnail), dataSize, "PNG");
      break;

    case OR_DATA_TYPE_PIXMAP_8RGB :
      qimage = QImage((uint8_t*) or_thumbnail_data(thumbnail),
          cx, cy, QImage::Format::Format_RGB888,
          (QImageCleanupFunction) (or_thumbnail_release), thumbnail);
      break;

    case OR_DATA_TYPE_PIXMAP_16RGB : {
      const uint16_t * thumbnail_data = (const uint16_t*) or_thumbnail_data(thumbnail);
      if ( thumbnail_data ) {
        uint8_t * scalled_data = (uint8_t *) malloc(dataSize /= 2);
        for ( uint i = 0; i < dataSize; ++i ) {
          scalled_data[i] = thumbnail_data[i] / 256;
        }
        qimage = QImage(scalled_data, cx, cy, QImage::Format::Format_RGB888,
            (QImageCleanupFunction) (free), scalled_data);
      }
    }
      break;

    default :
      // CF_DEBUG("%s: Thumbnail in unsupported format=%d, thumb size is %u, %u",
      //    cfilename.c_str(), thumbnailFormat, cx, cy);
      //or_thumbnail_release(thumbnail);
      break;
    }

    if ( thumbnail ) {
      or_thumbnail_release(thumbnail);
    }
  }

#elif HAVE_LIBRAW
  if ( true ) {
    static thread_local LibRaw RawProcessor;
    if ( RawProcessor.open_file(pathFileName.toStdString().c_str()) == LIBRAW_SUCCESS ) {
      if ( RawProcessor.unpack_thumb() == LIBRAW_SUCCESS ) {
        const libraw_thumbnail_t & T = RawProcessor.imgdata.thumbnail;
        if ( T.thumb ) {
          switch ( T.tformat ) {
            case LIBRAW_IMAGE_JPEG :
            qimage = QImage::fromData((uint8_t*) T.thumb, T.tlength, "JPG");
            break;
            case LIBRAW_IMAGE_BITMAP : {
              uint8_t * pixbuf = (uint8_t * )malloc(T.tlength);
              if ( pixbuf ) {
                memcpy(pixbuf, T.thumb, T.tlength);
                qimage = QImage(pixbuf, T.twidth, T.theight, QImage::Format_RGB888, free, pixbuf);
              }
              break;
            }
            default :
            break;
          }
        }
      }
      RawProcessor.recycle();
    }
  }

#endif

  return qimage;
}

QImage loadThumbnailImage(const QString & pathFileName, int thumb_size)
{
  QImage qimage;
  cv::Mat cvimage;

  const QString suffix = QFileInfo(pathFileName).suffix();
  if ( suffix.isEmpty() ) {
    return qimage;
  }

  if ( suffix.compare("ser", Qt::CaseInsensitive) == 0 ) {

    c_ser_reader ser(pathFileName.toStdString());

    if ( ser.read(cvimage) ) {

      //      if ( is_bayer_pattern(ser.color_id()) ) {
      //        debayer(cvimage, cvimage,
      //            ser.color_id(),
      //            DEBAYER_NN);
      //      }

      const QSize thumbSize =
          compute_thumbnail_size(QSize(cvimage.cols, cvimage.rows),
              thumb_size);

      if ( !thumbSize.isEmpty() && (thumbSize.width() != cvimage.cols || thumbSize.height() != cvimage.rows) ) {

        cv::resize(cvimage, cvimage,
            cv::Size(thumbSize.width(), thumbSize.height()),
            0, 0,
            cv::INTER_AREA);
      }

      cv2qimage(cvimage, &qimage, true);
      return qimage;
    }
  }

#if HAVE_CFITSIO
  if ( suffix.compare("fits", Qt::CaseInsensitive) == 0 || suffix.compare("fit", Qt::CaseInsensitive) == 0  ) {

    c_fits_reader fits(pathFileName.toStdString());

    if ( fits.read(cvimage) ) {

      //      if ( is_bayer_pattern(fits.color_id()) ) {
      //        debayer(cvimage, cvimage,
      //            fits.color_id(),
      //            DEBAYER_NN);
      //      }

      const QSize thumbSize =
          compute_thumbnail_size(QSize(cvimage.cols, cvimage.rows),
              thumb_size);

      if ( !thumbSize.isEmpty() && (thumbSize.width() != cvimage.cols || thumbSize.height() != cvimage.rows) ) {

        cv::resize(cvimage, cvimage,
            cv::Size(thumbSize.width(), thumbSize.height()),
            0, 0,
            cv::INTER_AREA);
      }

      cv2qimage(cvimage, &qimage, true);
      return qimage;
    }

  }
#endif


  if ( is_raw_file_suffix(suffix) ) {
    if ( !(qimage = loadThumbnailImageFromRaw(pathFileName, thumb_size)).isNull() ) {
      return qimage;
    }
  }

  if ( suffix.compare("flo", Qt::CaseInsensitive) == 0 ) {
    if ( !(cvimage = cv::readOpticalFlow(pathFileName.toStdString())).empty() ) {

      const QSize thumbSize =
          compute_thumbnail_size(QSize(cvimage.cols, cvimage.rows),
              thumb_size);

      if ( !thumbSize.isEmpty() && (thumbSize.width() != cvimage.cols || thumbSize.height() != cvimage.rows) ) {

        cv::resize(cvimage, cvimage,
            cv::Size(thumbSize.width(), thumbSize.height()),
            0, 0,
            cv::INTER_AREA);

      }

      cv2qimage(cvimage, &qimage, true);
      return qimage;
    }
  }


  static QMimeDatabase g_mimedb;
  const QMimeType mime = g_mimedb.mimeTypeForFile(pathFileName);

  if ( mime.name().contains("image/", Qt::CaseInsensitive) ) {

    if ( !mime.inherits("image/tiff") ) {

      QImageReader reader(pathFileName);
      if ( reader.canRead() ) {

        const QSize thumbSize =
            compute_thumbnail_size(reader.size(),
                thumb_size);

        reader.setAutoDetectImageFormat(true);
        reader.setQuality(75);
        reader.setScaledSize(thumbSize);

        qimage = reader.read();
        if ( !qimage.isNull() ) {
          if ( qimage.size().width() > thumbSize.width() || qimage.size().height() > thumbSize.height() ) {

            qimage = qimage.scaled(thumbSize,
                Qt::IgnoreAspectRatio,
                Qt::FastTransformation);

          }
          return qimage;
        }
      }
    }

    if ( load_image(pathFileName.toStdString(), cvimage) ) {

      if ( cvimage.channels() ==  2 ) {
        // interpret second channel as mask and ignore for preview,
        // because 2-channel image is interpreted by cv2qimage() as optical flow
        cv::extractChannel(cvimage, cvimage, 0);
      }

      const QSize thumbSize =
          compute_thumbnail_size(QSize(cvimage.cols, cvimage.rows),
              thumb_size);

      if ( !thumbSize.isEmpty() && (thumbSize.width() != cvimage.cols || thumbSize.height() != cvimage.rows) ) {

        cv::resize(cvimage, cvimage,
            cv::Size(thumbSize.width(), thumbSize.height()),
            0, 0,
            cv::INTER_AREA);

      }

      cv2qimage(cvimage, &qimage, true);
    }

    return qimage;
  }

  //CF_DEBUG("pathFileName: %s mime.name()=%s", pathFileName.toStdString().c_str(), mime.name().toStdString().c_str());
  bool is_video = mime.name().contains("video/", Qt::CaseInsensitive);
  if ( !is_video ) {
    const std::string csuffix = suffix.toLower().toStdString();
    const std::vector<std::string> & fmts = c_ffmpeg_reader::supported_input_formats();
    if ( std::find(fmts.begin(), fmts.end(), csuffix) != fmts.end() ) {
      is_video = true;
    }
  }

  if ( is_video ) {

#if HAVE_FFMPEG_READER
    c_ffmpeg_reader ffmpeg;

    if ( ffmpeg.open(pathFileName.toStdString()) ) {

      const QSize thumbSize = compute_thumbnail_size(QSize(ffmpeg.coded_size().width, ffmpeg.coded_size().height),
          thumb_size);
      if ( thumbSize.width() < ffmpeg.coded_size().width || thumbSize.height() < ffmpeg.coded_size().height ) {
        ffmpeg.set_frame_size(cv::Size(thumbSize.width(), thumbSize.height()));
      }

      //CF_DEBUG("pathFileName: %s ffmpeg.num_frames()=%d", pathFileName.toStdString().c_str(), ffmpeg.num_frames());
      if ( ffmpeg.num_frames() > 0 ) {
        ffmpeg.seek_frame(std::max(0, std::min(ffmpeg.num_frames() - 1, 5)));
      }

      if ( ffmpeg.read(cvimage, nullptr) ) {
        cv2qimage(cvimage, &qimage, true);
      }
    }

#else

    cv::VideoCapture cap;

    if ( cap.open(pathFileName.toStdString()) ) {

      // int nb_frames = cap.get(cv::CAP_PROP_FRAME_COUNT);
      // CF_DEBUG("pathFileName: %s CAP_PROP_FRAME_COUNT: %d", pathFileName.toStdString().c_str(), nb_frames);
      if ( cap.read(cvimage) ) {

        const QSize thumbSize =
        compute_thumbnail_size(QSize(cvimage.cols, cvimage.rows),
            thumb_size);

        if ( !thumbSize.isEmpty() && (thumbSize.width() != cvimage.cols || thumbSize.height() != cvimage.rows) ) {

          cv::resize(cvimage, cvimage,
              cv::Size(thumbSize.width(), thumbSize.height()),
              0, 0,
              cv::INTER_AREA);

        }

        cv2qimage(cvimage, &qimage, true);
      }
    }
#endif
  }

  return qimage;
}

QPixmap loadThumbnailPixmap(const QString & pathFileName, int maxSize)
{
  return QPixmap::fromImage(loadThumbnailImage(pathFileName, maxSize));
}

QIcon loadThumbnailIcon(const QString & pathFileName, int maxSize)
{
  return QIcon(loadThumbnailPixmap(pathFileName, maxSize));
}

bool isTextFileSuffix(const QString & suffix)
{
  const char ** suffixes =
      thumbnail_textfile_suffixes();

  for ( ; *suffixes; ++suffixes ) {
    if ( suffix.compare(*suffixes, Qt::CaseInsensitive) == 0 ) {
      return true;
    }
  }

  return false;
}

bool isPlyFileSuffix(const QString & suffix)
{
  const char ** suffixes =
      thumbnail_plyfile_suffixes();

  for ( ; *suffixes; ++suffixes ) {
    if ( suffix.compare(*suffixes, Qt::CaseInsensitive) == 0 ) {
      return true;
    }
  }

  return false;
}


bool isTextFile(const QString & abspath)
{
  return isTextFileSuffix(QFileInfo(abspath).suffix());
}

bool isPlyFile(const QString & abspath)
{
  return isPlyFileSuffix(QFileInfo(abspath).suffix());
}
