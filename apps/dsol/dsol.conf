odometry = {
	tbb = 0;                  // tbb grainsize
	log = 0;                  // log interval
	vis = 0;                  // show visualization
	num_kfs = 4;          // num kfs in window
	num_levels = 4;           // num pyramid levels
	min_track_ratio = 0.3;    // min track ratio to add new kf
	vis_min_depth = 4.0;      // min depth in visualization
	marg = false;             // enable marginalization
	reinit = false;           // reinitialize upon tracking failure
	init_depth = true;        // init from depth
	init_stereo = false;      // init from stereo
	init_align = false;       // init from align
}

selection = {
	sel_level = 1;       // pyramid level for initial selection
	cell_size = 16;      // cell size in top level
	min_grad = 8;        // mininum grad to be selected
	max_grad = 64;       // wont keep searching if we found pix > max_grad
	nms_size = 1;        // nms size when creating mask
	min_ratio = 0.0;     // decrease min_grad when ratio < min_ratio
	max_ratio = 1.0;     // increase min_grad when ratio > max_ratio
	reselect = false;   // reselect if first round is two low
}

stereo = {
	half_rows = 2;        // half rows of search window
	half_cols = 3;        // half cols of search window
	match_level = 3;      // match coarse level
	refine_size = 1;      // refine size
	min_zncc = 0.5;       // min zncc during refinement
	min_depth = 4.0;      // min depth -> max disp
	best_ratio = 0.8;     // filter score > best * best_ratio
}

align = {
	optm = {
		init_level = 0;   // init level to start optimzation
		max_iters = 8;    // num max iters per level
		max_xs = 0.1;  // max change in normalized change to stop early
	}

	cost = {
		affine = false;       // use affine brightness model
		stereo = false;       // use stereo images
		c2 = 2;                // gradient weight c^2, w_g = c^2 / (c^2 + dI^2)
		dof = 4;               // dof for t-dist, w_r = (dof + 1) / (dof + r^2)
		max_outliers = 1;      // max outliers in each patch
		grad_factor = 1.5;  // r^2 > grad_factor * g^2 is outlier
		min_depth = 0.2;    // min depth to skip when project
	}
}

adjust = {
	optm = {
		init_level = 0;   // init level to start optimzation
		max_iters = 8;    // num max iters per level
		max_xs = 0.1;  // max change in normalized change to stop early
	}
	cost = {
		affine = false;       // use affine brightness model
		stereo = false;       // use stereo images
		c2 = 2;                // gradient weight c^2, w_g = c^2 / (c^2 + dI^2)
		dof = 4;               // dof for t-dist, w_r = (dof + 1) / (dof + r^2)
		max_outliers = 1;      // max outliers in each patch
		grad_factor = 1.5;  // r^2 > grad_factor * g^2 is outlier
		min_depth = 0.2;    // min depth to skip when project
	}
}
